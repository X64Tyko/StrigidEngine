#include "../Public/Archetype.h"
#include "Profiler.h"
#include <algorithm>
#include <cassert>

Archetype::Archetype(const Signature& Sig)
    : ComponentSignature(Sig)
    , EntitiesPerChunk(0)
    , TotalEntityCount(0)
{
}

Archetype::~Archetype()
{
    // Clean up all allocated chunks
    for (Chunk* ChunkPtr : Chunks)
    {
        delete ChunkPtr;
    }
    Chunks.clear();
}

void Archetype::BuildLayout(const std::vector<ComponentMeta>& Components)
{
    if (Components.empty())
    {
        // Empty archetype - set a reasonable default capacity
        // (Useful for entities with only script component, no data components)
        constexpr size_t ReservedHeaderSpace = 64;
        size_t UsableSpace = Chunk::DATA_SIZE - ReservedHeaderSpace;
        EntitiesPerChunk = static_cast<uint32_t>(UsableSpace / 64); // Assume 64 bytes per entity minimum
        return;
    }

    // Calculate total stride (sum of all component sizes)
    size_t TotalStride = 0;
    size_t MaxAlignment = 1;

    for (const ComponentMeta& Meta : Components)
    {
        TotalStride += Meta.Size;
        MaxAlignment = std::max(MaxAlignment, Meta.Alignment);
    }

    // Calculate how many entities fit in a chunk
    // Reserve some space for potential chunk header in future
    constexpr size_t ReservedHeaderSpace = 64;
    size_t UsableSpace = Chunk::DATA_SIZE - ReservedHeaderSpace;
    
    if (TotalStride > 0)
    {
        EntitiesPerChunk = static_cast<uint32_t>(UsableSpace / TotalStride);
    }
    else
    {
        EntitiesPerChunk = static_cast<uint32_t>(UsableSpace / 64); // Minimum 64 bytes per entity
    }

    // Build SoA layout: [CompA, CompA, CompA...][CompB, CompB, CompB...]
    size_t CurrentOffset = ReservedHeaderSpace;

    for (const ComponentMeta& Meta : Components)
    {
        ComponentMeta LayoutMeta = Meta;
        
        // Align offset to component's alignment requirement
        size_t Misalignment = CurrentOffset % Meta.Alignment;
        if (Misalignment != 0)
        {
            CurrentOffset += (Meta.Alignment - Misalignment);
        }

        LayoutMeta.OffsetInChunk = CurrentOffset;
        ComponentLayout[Meta.TypeID] = LayoutMeta;

        // Advance offset by (size * capacity)
        CurrentOffset += Meta.Size * EntitiesPerChunk;
    }

    // Verify we didn't overflow chunk
    assert(CurrentOffset <= Chunk::DATA_SIZE && "Component layout exceeds chunk size!");
}

uint32_t Archetype::GetChunkCount(size_t ChunkIndex) const
{
    if (Chunks.empty() || ChunkIndex >= Chunks.size() || EntitiesPerChunk == 0)
        return 0;

    // If it's the last chunk, calculate remainder
    if (ChunkIndex == Chunks.size() - 1)
    {
        uint32_t Remainder = TotalEntityCount % EntitiesPerChunk;
        // Handle case where last chunk is exactly full
        return (Remainder == 0 && TotalEntityCount > 0) ? EntitiesPerChunk : Remainder;
    }

    // All other chunks are guaranteed full (dense packing invariant)
    return EntitiesPerChunk;
}

Archetype::EntitySlot Archetype::PushEntity()
{
    // Safety check for empty archetypes
    if (EntitiesPerChunk == 0)
    {
        EntitiesPerChunk = 256; // Default fallback
    }

    // Check if we need a new chunk
    if (TotalEntityCount % EntitiesPerChunk == 0)
    {
        Chunk* NewChunk = AllocateChunk();
        Chunks.push_back(NewChunk);
    }

    // Calculate which chunk and local index
    uint32_t ChunkIndex = TotalEntityCount / EntitiesPerChunk;
    uint32_t LocalIndex = TotalEntityCount % EntitiesPerChunk;

    EntitySlot Slot;
    Slot.TargetChunk = Chunks[ChunkIndex];
    Slot.LocalIndex = LocalIndex;
    Slot.GlobalIndex = TotalEntityCount;

    TotalEntityCount++;

    return Slot;
}

void Archetype::RemoveEntity(size_t ChunkIndex, uint32_t LocalIndex)
{
    // This will be implemented with active mask in future
    // For now, just placeholder
    // TODO: Mark entity as inactive in chunk's ActiveMask
    // Actual swap-and-pop happens during compaction phase
    
    (void)ChunkIndex;
    (void)LocalIndex;
}

void* Archetype::GetComponentArrayRaw(Chunk* TargetChunk, ComponentTypeID TypeID)
{
    auto It = ComponentLayout.find(TypeID);
    if (It == ComponentLayout.end())
        return nullptr;

    const ComponentMeta& Meta = It->second;
    return TargetChunk->GetBuffer(static_cast<uint32_t>(Meta.OffsetInChunk));
}

Chunk* Archetype::AllocateChunk()
{
    return new Chunk();
}
