void RenderThread::InterpolateToTransferBuffer(float alpha)
{
    STRIGID_ZONE_N("Render_Interpolate");
    size_t entityCount = SnapshotCurrent.size();

    if (entityCount == 0)
        return;

    // Calculate required size
    size_t requiredSize = sizeof(InstanceData) * entityCount;

    // Resize transfer buffer if needed
    if (!TransferBuffer || requiredSize > TransferBufferCapacity)
    {
        if (TransferBuffer)
        {
            SDL_ReleaseGPUTransferBuffer(GpuDevice, TransferBuffer);
        }

        SDL_GPUTransferBufferCreateInfo transferInfo = {};
        transferInfo.usage = SDL_GPU_TRANSFERBUFFERUSAGE_UPLOAD;
        transferInfo.size = static_cast<uint32_t>(requiredSize * 2); // 2x headroom

        TransferBuffer = SDL_CreateGPUTransferBuffer(GpuDevice, &transferInfo);
        TransferBufferCapacity = requiredSize * 2;

        LOG_INFO_F("[RenderThread] Transfer buffer resized to %zu bytes", TransferBufferCapacity);
    }

    // Map transfer buffer
    void* mapped = SDL_MapGPUTransferBuffer(GpuDevice, TransferBuffer, true); // true = cycle
    if (!mapped)
    {
        LOG_ERROR("[RenderThread] Failed to map transfer buffer");
        return;
    }

    InstanceData* instances = static_cast<InstanceData*>(mapped);

    // Interpolate between SnapshotPrevious and SnapshotCurrent
    for (size_t i = 0; i < entityCount; ++i)
    {
        const SnapshotEntry& prev = (i < SnapshotPrevious.size()) ? SnapshotPrevious[i] : SnapshotCurrent[i];
        const SnapshotEntry& curr = SnapshotCurrent[i];

        // Lerp position
        instances[i].PositionX = prev.PositionX + (curr.PositionX - prev.PositionX) * alpha;
        instances[i].PositionY = prev.PositionY + (curr.PositionY - prev.PositionY) * alpha;
        instances[i].PositionZ = prev.PositionZ + (curr.PositionZ - prev.PositionZ) * alpha;

        // Lerp rotation
        instances[i].RotationX = prev.RotationX + (curr.RotationX - prev.RotationX) * alpha;
        instances[i].RotationY = prev.RotationY + (curr.RotationY - prev.RotationY) * alpha;
        instances[i].RotationZ = prev.RotationZ + (curr.RotationZ - prev.RotationZ) * alpha;

        // Lerp scale
        instances[i].ScaleX = prev.ScaleX + (curr.ScaleX - prev.ScaleX) * alpha;
        instances[i].ScaleY = prev.ScaleY + (curr.ScaleY - prev.ScaleY) * alpha;
        instances[i].ScaleZ = prev.ScaleZ + (curr.ScaleZ - prev.ScaleZ) * alpha;

        // Copy color (no interpolation)
        instances[i].ColorR = curr.ColorR;
        instances[i].ColorG = curr.ColorG;
        instances[i].ColorB = curr.ColorB;
        instances[i].ColorA = curr.ColorA;
    }

    SDL_UnmapGPUTransferBuffer(GpuDevice, TransferBuffer);

    LOG_DEBUG_F("[RenderThread] Interpolated %zu instances (alpha=%.3f)", entityCount, alpha);
}
