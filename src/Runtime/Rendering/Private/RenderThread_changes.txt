=== CHANGES NEEDED FOR RENDERTHREAD ===

1. RenderThread.h - Update function signatures (lines 66, 69, 71):

OLD:
    void InterpolateToTransferBuffer(float alpha);
    void BuildCopyPassAndUniforms();
    void BuildRenderPass();

NEW:
    bool InterpolateToTransferBuffer(float alpha); // Returns false on failure
    bool BuildCopyPassAndUniforms();               // Returns false on failure
    bool BuildRenderPass();                        // Returns false on failure

2. RenderThread.cpp - Update InterpolateToTransferBuffer implementation:

bool RenderThread::InterpolateToTransferBuffer(float alpha)
{
    STRIGID_ZONE_N("Render_Interpolate");
    size_t entityCount = SnapshotCurrent.size();

    if (entityCount == 0)
        return true; // Not a failure, just nothing to do

    // Calculate required size
    size_t requiredSize = sizeof(InstanceData) * entityCount;

    // Resize transfer buffer if needed
    if (!TransferBuffer || requiredSize > TransferBufferCapacity)
    {
        if (TransferBuffer)
        {
            SDL_ReleaseGPUTransferBuffer(GpuDevice, TransferBuffer);
        }

        SDL_GPUTransferBufferCreateInfo transferInfo = {};
        transferInfo.usage = SDL_GPU_TRANSFERBUFFERUSAGE_UPLOAD;
        transferInfo.size = static_cast<uint32_t>(requiredSize * 2); // 2x headroom

        TransferBuffer = SDL_CreateGPUTransferBuffer(GpuDevice, &transferInfo);
        if (!TransferBuffer)
        {
            LOG_ERROR("[RenderThread] Failed to create transfer buffer");
            return false;
        }

        TransferBufferCapacity = requiredSize * 2;
        LOG_INFO_F("[RenderThread] Transfer buffer resized to %zu bytes", TransferBufferCapacity);
    }

    // Map transfer buffer
    void* mapped = SDL_MapGPUTransferBuffer(GpuDevice, TransferBuffer, true); // true = cycle
    if (!mapped)
    {
        LOG_ERROR("[RenderThread] Failed to map transfer buffer");
        return false;
    }

    InstanceData* instances = static_cast<InstanceData*>(mapped);

    // Interpolate between SnapshotPrevious and SnapshotCurrent
    for (size_t i = 0; i < entityCount; ++i)
    {
        const SnapshotEntry& prev = (i < SnapshotPrevious.size()) ? SnapshotPrevious[i] : SnapshotCurrent[i];
        const SnapshotEntry& curr = SnapshotCurrent[i];

        // Lerp position
        instances[i].PositionX = prev.PositionX + (curr.PositionX - prev.PositionX) * alpha;
        instances[i].PositionY = prev.PositionY + (curr.PositionY - prev.PositionY) * alpha;
        instances[i].PositionZ = prev.PositionZ + (curr.PositionZ - prev.PositionZ) * alpha;

        // Lerp rotation
        instances[i].RotationX = prev.RotationX + (curr.RotationX - prev.RotationX) * alpha;
        instances[i].RotationY = prev.RotationY + (curr.RotationY - prev.RotationY) * alpha;
        instances[i].RotationZ = prev.RotationZ + (curr.RotationZ - prev.RotationZ) * alpha;

        // Lerp scale
        instances[i].ScaleX = prev.ScaleX + (curr.ScaleX - prev.ScaleX) * alpha;
        instances[i].ScaleY = prev.ScaleY + (curr.ScaleY - prev.ScaleY) * alpha;
        instances[i].ScaleZ = prev.ScaleZ + (curr.ScaleZ - prev.ScaleZ) * alpha;

        // Copy color (no interpolation)
        instances[i].ColorR = curr.ColorR;
        instances[i].ColorG = curr.ColorG;
        instances[i].ColorB = curr.ColorB;
        instances[i].ColorA = curr.ColorA;
    }

    SDL_UnmapGPUTransferBuffer(GpuDevice, TransferBuffer);

    LOG_DEBUG_F("[RenderThread] Interpolated %zu instances (alpha=%.3f)", entityCount, alpha);
    return true;
}

3. RenderThread.cpp - Update BuildCopyPassAndUniforms to return bool:

bool RenderThread::BuildCopyPassAndUniforms()
{
    SDL_GPUCommandBuffer* cmdBuf = CmdBufferAtomic.load(std::memory_order_acquire);
    size_t entityCount = SnapshotCurrent.size();

    if (entityCount == 0 || !Pipeline)
    {
        LOG_WARN("[RenderThread] No entities or pipeline missing");
        return false; // Changed from return to return false
    }

    // ... rest of implementation ...
    // Add error checking for buffer creation and return false on failure

    return true; // Success
}

4. RenderThread.cpp - Update BuildRenderPass to return bool:

bool RenderThread::BuildRenderPass()
{
    size_t entityCount = SnapshotCurrent.size();

    SDL_GPUCommandBuffer* cmdBuf = CmdBufferAtomic.load(std::memory_order_acquire);
    SDL_GPUTexture* swapchainTex = SwapchainTextureAtomic.load(std::memory_order_acquire);

    if (!cmdBuf || !swapchainTex)
    {
        LOG_ERROR("[RenderThread] Missing GPU resources in BuildRenderPass");
        return false;
    }

    // ... rest of implementation ...
    // Add error checking and return false on failure

    return true; // Success
}

5. RenderThread.cpp - Update ThreadMain to handle failures (lines 103-125):

OLD:
    RequestGPUResources();
    float alpha = CalculateInterpolationAlpha();
    InterpolateToTransferBuffer(alpha);
    WaitForCommandBuffer();
    BuildCopyPassAndUniforms();
    WaitForSwapchainTexture();
    BuildRenderPass();
    SignalReadyToSubmit();

NEW:
    RequestGPUResources();
    float alpha = CalculateInterpolationAlpha();

    if (!InterpolateToTransferBuffer(alpha))
    {
        WaitForCommandBuffer(); // Still need to wait for resources
        WaitForSwapchainTexture();
        SignalReadyToSubmit(); // Submit empty/partial frame
        continue;
    }

    WaitForCommandBuffer();

    if (!BuildCopyPassAndUniforms())
    {
        WaitForSwapchainTexture();
        SignalReadyToSubmit(); // Submit partial frame
        continue;
    }

    WaitForSwapchainTexture();

    if (!BuildRenderPass())
    {
        SignalReadyToSubmit(); // Submit partial frame
        continue;
    }

    SignalReadyToSubmit();
